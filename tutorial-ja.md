% Rust 言語チュートリアル (非公式日本語訳)

# イントロダクション

## 範囲

これは Rust プログラミング言語のチュートリアルです。読者はプログラミングの基本
的な概念に慣れていて、一つ以上、他言語でプログラミング経験があると仮定していま
す。しばし C 系統の他言語と比較を行います。このチュートリアルは言語全体をカバー
しますが、[言語仕様書](rust.html)ほどの深さと正確さはありません。

## 言語の概要

Rust は、型安全性、メモリ安全性、並列性、パフォーマンスに焦点を置いたシステムプ
ログラミング言語です。 C++ のような言語でよく起こるある種のエラーを避けつつ、大
規模で高パフォーマンスのアプリケーションを書くことに向いています。 Rust は洗練
されたメモリモデルを持っており、 C++ で使われるようなたくさんの効率的なデータ構
造を利用可能にすると同時に、セグメンテーション違反を起こす無効なメモリアクセス
を禁止します。他のシステム言語のように、静的に型付けされ、事前コンパイル (ahead
of time compilation) されます。

マルチパラダイム言語として、手続き的、関数的、オブジェクト指向的なスタイルでコ
ードを書くことに対して、強力なサポートがあります。その素敵で高レベルな特徴とし
て、次のようなものがあります。

* パターンマッチングおよび代数的データ型 (enum) - 関数型言語でよく使われてい
  るもので、 ADT のパターンマッチングはプログラムのロジックを記述するための、簡
  潔で表現しやすい方法を提供します。
* タスクベース並列性 - Rust はメモリを共有しない軽量なタスクを用います。
* 高階関数 - Rust のクロージャはとてもパワフルで、至るところで使われます。
* 多相性 - Rust の型システムは、 Java スタイルのインターフェイスと Haskell スタ
  イルの型クラスのユニークな組み合わせを特徴としています。
* ジェネリクス - 関数と型は総称型として、オプショナルな型制約を伴って型をパラメー
  タ化できます。

## ファーストインプレッション

C, C++, JavaScript の伝統を受け継いだ波括弧を多用する言語として、 Rust は読者が
慣れ親しんでいる他の言語と見た目がよく似ています。

~~~~
fn boring_old_factorial(n: int) -> int {
    let mut result = 1, i = 1;
    while i <= n {
        result *= i;
        i += 1;
    }
    ret result;
}
~~~~

いくつか C と異なる部分が現れています。型は変数名の前ではなく後に置かれ、前にコ
ロンが付きます。 `let` で導入されるローカル変数では型を省略可能で、省略した場合
は推論されます。 `while` や `if` のような構文では条件式を囲む括弧は必要ありませ
ん (ただし囲うことも許されます) 。また、キーワードは積極的に短縮される傾向にあ
ります。例えば、 function は `fun` 、 return は `ret` のようにです。

しかし、 Rust が単純な C の発展形であると結論しないでください。このチュートリア
ルで明らかになるように、 Rust はたくさんの高レベルなイディオムのために、効率的
で、強い型付けを持ち、メモリ安全性をサポートするという、全く違う方向性を持ちま
す。

ここにあなたの興味をそそる並列じゃんけんゲームがあります。

~~~~
use std;

import comm::{listen, methods};
import task::spawn;
import iter::repeat;
import rand::{seeded_rng, seed};
import uint::range;
import io::println;

fn main() {
    // ゲームの結果を受け取るためのチャンネルを開く。
    do listen |result_from_game| {

        let times = 10;
        let player1 = ~"graydon";
        let player2 = ~"patrick";

        for repeat(times) {
            // ゲームを行うための別タスクを開始する。
            do spawn |copy player1, copy player2| {
                let outcome = play_game(player1, player2);
                result_from_game.send(outcome);
            }
        }

        // ゲームが完了したら、結果を報告する。
        for range(0, times) |round| {
            let winner = result_from_game.recv();
            println(#fmt("%s wins round #%u", winner, round));
        }
    }

    fn play_game(player1: ~str, player2: ~str) -> ~str {

        // グー/パー/チョキ の型
        enum gesture {
            rock, paper, scissors
        }

        let rng = seeded_rng(seed());
        // 手を選ぶ小さなインライン関数
        let pick = || (~[rock, paper, scissors])[rng.gen_uint() % 3];

        // 二つの手を選び、結果を判断する。
        alt (pick(), pick()) {
            (rock, scissors) | (paper, rock) | (scissors, paper) { copy player1 }
            (scissors, rock) | (rock, paper) | (paper, scissors) { copy player2 }
            _ { ~"tie" }
        }
    }
}
~~~~

## 慣例

このチュートリアル全体を通して、言語のキーワードを示す単語やコード例の中で定義
される識別子を `code font` で記述します。

コード片はインデントされ、固定幅フォントで記述されます。コード片がプログラム全
体を構成するとは限りません。簡潔さのため、それ自身はコンパイルできないプログラ
ムの断片を見せることがあります。試してみるためには、そのコードを
`fn main() { ...  }` で囲う必要があるかもしれません。また、実際に定義されていな
いものへの参照を含まないことを確認してください。

> ***警告:*** Rust は非常に開発途上の言語です。言語の変更や実装の欠如の可能性、
> その他ブロッククォート上で示される警告に注意してください。

# げてぃん・すたーてっ

## インストール

Rust コンパイラは現在のところ [tarball][] からビルドする必要があります。将来的
にはたくさんの OS に対しバイナリパッケージを配布しようと思っています。

Rust コンパイラはそれ自身が Rust で書かれているため、 (開発のより前の段階で作ら
れた) コンパイル済みの「スナップショット」バージョンでビルドする必要があるとい
う点が、少しだけ通常と異なります。ソースビルドには次のものが必要です。

  * スナップショットをダウンロードするするため、インターネットに接続されている
	こと。
  * 我々が提供しているスナップショットバイナリのどれかを実行できること。
    * Windows (7, server 2008 r2), x86 のみ
    * Linux (various distributions), x86 と x86-64
    * OSX 10.6 ("Snow Leopard") または 10.7 ("Lion"), x86 と x86-64

この他のプラットフォームでも動作するかもしれませんが、最も動作する可能性の高い、
"tier 1" としてサポートされるビルド環境が存在します。将来、クロスコンパイルによっ
てさらに多くのプラットフォームが加えられるでしょう。

ソースからビルドするには、次のパッケージが必要です。

  * g++ 4.4 or clang++ 3.x
  * python 2.6 or later
  * perl 5.0 or later
  * gnu make 3.81 or later
  * curl

あなたが比較的新しい *nix を使っていて上の条件を満たしていれば、だいたいうまく
いくはずです。 Windows 上でソースからビルドするには追加の手順が必要です。 Rust
wiki の [getting started][wiki-get-started] を参照してください。

~~~~ {.notrust}
$ wget http://dl.rust-lang.org/dist/rust-0.3.tar.gz
$ tar -xzf rust-0.3.tar.gz
$ cd rust-0.3
$ ./configure
$ make && make install
~~~~

インストール先のディレクトリを修正する権限がない場合、 `sudo make install` を使
う必要があるかもしれません。インストール先は `configure` に引数 `--prefix` を渡
すことで変更できます。他のいろいろなオプションもサポートされています。詳細を知
りたいときは `--help` を渡してください。

ビルドが完了すれば、 `make install` で次のプログラムが `/usr/local/bin` にイン
ストールされます。

  * `rustc`, Rust コンパイラ
  * `rustdoc`, API ドキュメンテーションツール
  * `cargo`, Rust パッケージマネージャ

[wiki-get-started]: https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust
[tarball]: http://dl.rust-lang.org/dist/rust-0.3.tar.gz

## 最初のプログラムをコンパイルする

Rust のプログラムファイルは、慣例として拡張子 `.rs` が与えられます。次の内容の
ファイル `hello.rs` があるとします。

~~~~
fn main(args: ~[~str]) {
    io::println(~"hello world from '" + args[0] + ~"'!");
}
~~~~

Rust コンパイラが正しくインストールされていれば、 `rustc hello.rs` を実行すると
`hello` (もしくは `hello.exe`) というバイナリが生成されるはずです。

もしこのプログラムを不正になるように修正し (例えば、 `io::println` を何か存在し
ない関数に換える) 、コンパイルしたら、次のようなエラーメッセージが表示されるで
しょう。

~~~~ {.notrust}
hello.rs:2:4: 2:16 error: unresolved name: io::print_it
hello.rs:2     io::print_it(~"hello world from '" + args[0] + ~"'!");
               ^~~~~~~~~~~~
~~~~

Rust コンパイラはエラーに出くわしたとき、役立つ情報を提供しようとします。

## Rust プログラムの構造

一番単純な形式の Rust プログラムは、型と関数が定義されている `.rs` ファイルだけ
から成ります。もし `main` 関数が存在すれば、実行形式にコンパイルできます。 Rust
は、宣言でないコードがファイルのトップレベルに現れることを許しません。つまり、
全てのステートメントは関数の中になければいけません。

Rust プログラムはライブラリとしてもコンパイルでき、他のプログラムにインクルード
され得ます。
多く例の一番上に現れる `use std` ディレクティブは、[標準ライブラリ][std]をイン
ポートします。これについては[後ほど](#modules-and-crate)より詳細に記述します。

[std]: http://doc.rust-lang.org/doc/std

## Rust コードの編集

Rust のソース配布物の `src/etc/vim/` に Vim のハイライトとインデントを行うスク
リプトが、また `src/etc/emacs/` に emacs mode があります。

他のエディタ向けのものはまだ提供されていません。もしあなたが好きなエディタ向け
の Rust モードを書いたら、私たちがリンクできるよう知らせてください。

# 構文の基本

## ブレース

あなたが C 系統の言語 (C++, Java, JavaScript, C#, PHP) でプログラムしたことがあ
れば、 Rust は親しみやすく感じられるでしょう。主な表面的な違いは、 `if` ステー
トメントと `while` ループの本体をブラケットで囲む*必要がある*ということです。単一
のステートメントであっても、ブラケットで囲われていない本体は許されません。

この冗長性が煩わしいと感じるなら、こうすることで `if`, `while` やその他の似た構
文で、条件式のまわりの括弧を省略できるという事実を考えてみてください。これは常
に 2 文字をセーブできます。ついでに、ブレースを追加する必要があるかどうか決めた
り、 `if` のブランチにステートメントを追加した後にブレースを追加するのにエネル
ギーを費やす必要もなくなります。

これらの違いを理解すれば、 Rust のステートメントと式の表面的な構文は C ライクで
す。関数呼び出しは `myfunc(arg1, arg2)` と記述され、演算子は C とおおむね同じ名
前と優先順位を持ち、コメントは同じであり、 `if` や `while` のような構文が利用で
きます。

~~~~
# fn call_a_function(_a: int) {}
fn main() {
    if 1 < 2 {
        while false { call_a_function(10 * 4); }
    } else if 4 < 3 || 3 < 4 {
        // C++ スタイルのコメント
    } else {
        /* 複数行コメントの構文 */
    }
}
~~~~

## 式の構文

全てのコード上で明白なわけではありませんが、 Rust の構文と C 系統の先行する言語
との間には基本的な違いがあります。 C ではステートメントであるたくさんのものが、
Rust では式です。これは次のような無益なもの (関数に void 型の nil を渡す) を許
します。

~~~~
# fn a_function(_a: ()) {}
a_function(while false {});
~~~~

しかし同時に、次のような有益なものも許されます。

~~~~
# fn the_stars_align() -> bool { false }
# fn something_else() -> bool { true }
let x = if the_stars_align() { 4 }
        else if something_else() { 3 }
        else { 0 };
~~~~

このコードは `x` に、条件に依存する値を束縛します。条件の中身、
`{ expression }` に注意してください。ブレースで囲まれたブロックにおいて、最後の
ステートメントの後のセミコロンがない場合、ブロック全体には最後の式の値が与えら
れます。もし `if` のブランチが `{ 4; }` のようになっていたら、上の例は単に `x`
に nil (void) が代入されます。しかしセミコロンなしだと、それぞれのブランチは違
う値を持ち、 `x` は実行されるブランチの値になります。

これは関数本体でも有効です。次の関数はブール値を返します。

~~~~
fn is_four(x: int) -> bool { x == 4 }
~~~~

手短に言えば、宣言 (変数に対する `let`, 関数に対する `fn`, その他) でない全ての
ものは式です。

もしこれら全てが式だとしたら、*全ての*ステートメント、つまり C では伝統的にセミ
コロンで終端しない `while` などの後にさえ、終端のセミコロンを追加する必要がある
と結論するかもしれません。しかしこれは正しくありません。ブロックで終わる式は、
そのブロックが終端に式を含んでいるときだけ (if that block contains a trailing
expression) セミコロンが必要です。 `while` ループは終端に式を許しません。また
`if` ステートメントは、その値を使いたいときのみ終端に式を持つ傾向にあります。そ
の場合、 `if` 式は上の例での `let x = ...` のような、より大きなステートメントに
埋め込まれているでしょう。

## 識別子

Rust の識別子はアルファベットかアンダースコアから始まり、その後に英数字とアンダー
スコアが続きます。

ダブルコロン (`::`) はモジュールセパレータとして使われます。なので、
`io::println` は「 `io` という名前のモジュールの中にある、 `println` という名前
のもの」を意味します。

Rust は通常、使われていない変数に対して警告を出します。これはアンダースコアから
始まる変数名を使うことで抑制できます。

~~~~
fn this_warns(x: int) {}
fn this_doesnt(_x: int) {}
~~~~

## 変数宣言

今まで見てきたように、 `let` キーワードはローカル変数を導入します。ローカル変数
はデフォルトで immutable です。 `let mut` を用いることで、再代入できる変数を導
入できます。グローバル定数は `const` で定義できます。

~~~~
use std;
const repeat: uint = 5u;
fn main() {
    let hi = ~"Hi!";
    let mut count = 0u;
    while count < repeat {
        io::println(hi);
        count += 1u;
    }
}
~~~~

ローカル変数は前の宣言を隠し、前の変数をスコープから外す可能性があります。

~~~~
let my_favorite_value: float = 57.8;
let my_favorite_value: int = my_favorite_value as int;
~~~~

## 型

`is_four` の例にある `-> bool` は、関数の戻り型を記述する方法です。意味のある値
を返さない関数 (Rust では nil を返します) の場合、 `-> ()` (`()` は nil の記述
法) とオプショナルに記述できます。しかし、今まで見てきた `fn main() { ...}` の
ように、普通は戻り型の注釈は単に省略します。

関数の引数は全て `x: int` のように型を宣言する必要があります。関数内ではほとん
どのローカルなものに対し、型推論が可能です (後述する総称関数はときどき注釈が必
要です) 。ローカルなものは型注釈ありでもなしでも記述できます。

~~~~
// The type of this vector will be inferred based on its use.
let x = ~[];
# vec::map(x, fn&(&&_y:int) -> int { _y });
// Explicitly say this is a vector of integers.
let y: ~[int] = ~[];
~~~~

基本型は次のように記述します。

`()`
  : Nil, the type that has only a single value.

`bool`
  : Boolean type, with values `true` and `false`.

`int`
  : A machine-pointer-sized integer.

`uint`
  : A machine-pointer-sized unsigned integer.

`i8`, `i16`, `i32`, `i64`
  : Signed integers with a specific size (in bits).

`u8`, `u16`, `u32`, `u64`
  : Unsigned integers with a specific size.

`f32`, `f64`
  : Floating-point types.

`float`
  : The largest floating-point type efficiently supported on the target machine.

`char`
  : A character is a 32-bit Unicode code point.

`~str`
  : String type. A string contains a UTF-8 encoded sequence of characters.

これらは複合型 (詳細は後述) と組み合わせられます。ここで `T` は任意の型を表しま
す。

`~[T]`
  : Vector type.

`~[mut T]`
  : Mutable vector type.

`(T1, T2)`
  : Tuple type. Any arity above 1 is supported.

`{field1: T1, field2: T2}`
  : Record type.

`fn(arg1: T1, arg2: T2) -> T3`, `fn@()`, `fn~()`, `fn&()`
  : Function types.

`@T`, `~T`, `*T`
  : Pointer types.

型は `type` 宣言により名前を与えることが可能です。

~~~~
type monster_size = uint;
~~~~

これは符号無し整数型に `moster_size` というシノニムを提供します。
`monster_size` という新しい型を作るのではありません。 `monster_size` と `uint`
は互いに交換可能な形で使え、一方の名前が期待される場所でもう一方の名前を使って
も型エラーを引き起こしません。単なるシノニムでない型を作る必要があるなら、 
[single-variant enums](#single_variant_enum) を読んでください。

## 数値リテラル

整数は 10 進数 (`144`) 、16 進数 (`0x90`) 、 2 進数 (`0b10010000`) で記述できま
す。サフィックスなしで (`3`, `-500`, etc.) 整数リテラルを書いたら、 Rust コンパ
イラはその型を型注釈と周囲の関数のシグニチャから推論しようとします。次の例で
`x` は `u16` の引数を取る関数に渡されるので、 `u16` と推論されます。

~~~~
let x = 3;

fn identity_u16(n: u16) -> u16 { n }

identity_u16(x);
~~~~

一方で、プログラムがサフィックスのないリテラルの型について矛盾する情報を与える
場合、エラーメッセージを受け取るでしょう。

~~~~{.xfail-test}
let x = 3;
let y: i32 = 3;

fn identity_u8(n: u8) -> u8 { n }
fn identity_u16(n: u16) -> u16 { n }

identity_u8(x);  // after this, `x` is assumed to have type `u8`
identity_u16(x); // raises a type error (expected `u16` but found `u8`)
identity_u16(y); // raises a type error (expected `u16` but found `i32`)
~~~~

型注釈が全くない場合、 Rust はサフィックスのない整数リテラルを `int` 型と仮定し
ます。

~~~~
let n = 50;
log(error, n); // n is an int
~~~~

整数リテラルをサフィックス付きで記述して、型の曖昧さを避けることも可能です。サ
フィックス `i` と `u` はそれぞれ `int` と `uint` 型を表します。つまりリテラル
`-3i` は `int` 型になり、 `127u` は `uint` 型になります。固定サイズの整数型に対
しては、単にリテラルに型名を付け加えます。 `255u8`, `50i64` などです。

Rust では整数型同士の暗黙の変換が行われないことに注意してください。 `uint` 型の
変数に 1 を足すとき、 `+= 1u8` と書くと型エラーになります。

浮動小数点数は `0.0`, `1e6`, `2.1e-7` と記述します。サフィックスなしだと、リテ
ラルは `float` 型だと仮定されます。サフィックス `f32` と `f64` は特定の型を持つ
リテラルを作るのに使えます。サフィックス `f` はドットや指数部なしで `float` リ
テラルを記述するに使えます。 `3f` などです。

## 他のリテラル

nil リテラルは型と同じように `()` と記述します。キーワード `true` と `false` は
ブールリテラルを生成します。

文字リテラルは `'x'` のようにシングルクォートの間に記述します。非アスキー文字も
記述できます。 (ソースファイルは utf-8 でエンコードするべきです) 。 Rust はバッ
クスラッシュを用いて、いくつかのキャラクタエスケープを認識します。

`\n`
  : A newline (Unicode character 10).

`\r`
  : A carriage return (13).

`\t`
  : A tab character (9).

`\\`, `\'`, `\"`
  : Simply escapes the following character.

`\xHH`, `\uHHHH`, `\UHHHHHHHH`
  : Unicode escapes, where the `H` characters are the hexadecimal digits that
    form the character code.

文字列リテラルもまた同じエスケープシーケンスを許容します。それらはダブルクォー
トの間に記述されます (`"hello"`) 。 Rust の文字列は改行を含むことがあります。改
行の前にバックスラッシュがある場合、改行とそれに続く空白は無視されます。従って
次の例は `~"abc"` と等価です。

~~~~
let s = ~"a\
         b\
         c";
~~~~

## 演算子

Rust の演算子に驚くようなところはほとんどありません。二項演算子は `*`, `/`,
`%`, `+`, `-` (乗算、除算、剰余、加算、減算) で行われます。 `-` は negation す
る単項演算子でもあります。

シフト演算は `>>` (右シフト) 、 `<<` (左シフト) で行われます。右シフトは値が符
号付きなら算術シフト、符号無しなら論理シフトです。論理ビット演算子は `&`, `|`,
`^` (論理積、論理和、排他論理和) で、単項 `!` 演算子はビット反転 (またはブール
値に適用された場合、ブール値の反転) に用いられます。

比較演算子は伝統的な `==`, `!=`, `<`, `>`, `<=`, `>=` です。ショートサーキット
(遅延評価される) ブール演算子は `&&` (かつ) と `||` (または) と書かれます。

Rust は型変換に `as` 演算子を使います。この演算子は、乗算と除算の次に高い優先順
位を持ちます。左側に式、右側に型を取り、意味のある変換が存在する場合、式の結果
を与えられた型に変換します。

~~~~
let x: float = 4.0;
let y: uint = x as uint;
assert y == 4u;
~~~~

C との主な違いは `++` と `--` がないことと、論理ビット演算子がより高い優先順位
を持つことです。 `x & 2 > 0` は C では `x & (2 > 0)` という結果になり、 Rust で
は `(x & 2) > 0` を意味します。これはあなたが (C の熟練者でなければ) 期待したも
のに、より近いはずです。

## 属性

## 構文拡張

# 制御構造

## 条件文

## パターンマッチ

## 構造を分解する let

## ループ

## 失敗

## アサーション

## ロギング

# 関数

# 基本データ型

Rust のコアデータ型は、 structual なレコードと、 enums (タグ付けされた共用体、
代数的データ型) と、タプルです。これらはデフォルトで immutable です。

~~~~
type point = {x: float, y: float};

enum shape {
    circle(point, float),
    rectangle(point, point)
}
~~~~

## レコード

Rust のデータ型は `{field1: T1, field2: T2 [, ...]}` と記述します。ここで `T1`,
`T2` は型を表します。レコードリテラルは同じ方法で記述しますが、型の代わりに式を
書きます。これは C の構造体に非常に似ていて、メモリ上に同じ方法で置かれます (従
って、 Rust から C の構造体を読むことが可能で、その逆も同様です) 。レコードのフ
ィールドにアクセスするには、ドット演算子を用います (`mypoint.x`) 。

mutable にしたいフィールドは明示的に `mut` と記す必要があります。

~~~~
type stack = {content: ~[int], mut head: uint};
~~~~

このような型では、 `mystack.head += 1u` とできます。仮に `mut` を型から省略した
場合、このような代入は型エラーになります。

既に存在するレコードを基にして新しいレコードを作るためには、 `with` キーワード
を用います。

~~~~
let oldpoint = {x: 10f, y: 20f};
let newpoint = {x: 0f with oldpoint};
assert newpoint == {x: 0f, y: 20f};
~~~~

これは新しいレコードを作り、リテラルで明示的にセットされる 1 つを除いて、
`oldpoint` から全てのフィールドをコピーします。

Rust のレコード型は *structural* です。これは `{x: float, y: float}` が単に新た
な型を定義する方法というだけではなく、実際の型名であるということを意味します。
レコード型は最初にそれを定義することなく使えます。モジュール A が
`type point = {x: float, y: float}` を定義していて、モジュール B が A について
何も知らないまま `{x: float, y: float}` を返す関数を定義しているとき、その返値
をモジュール A 内で `point` として使えます。 (`type` が型に追加の名前を定義し、
実際に新しい型を定義するわけではないことを思い出してください)

## レコードのパターン

レコードは `alt` パターンによって分解できます。基本的な構文は
`{fieldname: pattern, ...}` ですが、フィールドと同名の変数を束縛する場合パター
ンは省略可能です。

~~~~
# let mypoint = {x: 0f, y: 0f};
alt mypoint {
    {x: 0f, y: y_name} { /* Provide sub-patterns for fields */ }
    {x, y}             { /* Simply bind the fields */ }
}
~~~~

レコードのフィールド名は、型で現れるのと同じ順序でパターンに現れる必要はありま
せん。レコードの全フィールドには興味がない場合、他のフィールドを無視することを
示すために、レコードパターンを `, _` で終えます (`{field1, _}` のように) 。

## enum

enum はいくつかの異なった表現を持つデータ型です。さきほど示した例を考えましょう。

~~~~
# type point = {x: float, y: float};
enum shape {
    circle(point, float),
    rectangle(point, point)
}
~~~~

この型の値は circle か rectangle のどちらか一方であり、 circle の場合は point
レコードと float 、 rectangle の場合は二つの point レコードを持ちます。このよう
な値の実行時表現には、実際に保持している形式を識別するための ID が含まれていま
す。これは C での「タグ付き共用体」に非常に似ていますが、人間工学的により良いも
のです (with better ergonomics) 。

上の宣言は、これらに対応する型 (XXX: 原文の refer to はポインタ的な意味ではない
はず。要確認)  `shape` を定義し、さらに値を構築するために使う関数 `circle` と
`rectangle` を定義します (指定された型の引数を取ります) 。よって、
`circle({x: 0f, y: 0f}, 10f)` とすると、新しい circle が作られます。

enum ヴァリアントは必ずしも型パラメタを持つ必要はありません。次の例は C の enum
と等価です。

~~~~
enum direction {
    north,
    east,
    south,
    west
}
~~~~

これは `north`, `east`, `south`, `west` を定数として定義し、その型は全て
`direction` になります。

enum が C ライクなとき、つまりパラメタを取るヴァリアントが存在しない場合、識別
子 (discriminator) の値を明示的に設定できます。

~~~~
enum color {
  red = 0xff0000,
  green = 0x00ff00,
  blue = 0x0000ff
}
~~~~

明示的な識別子がヴァリアントに指定されない場合、値は一つ前のヴァリアントの値 +
1 になります。最初のヴァリアントが識別子を持たない場合、値は 0 になります。例え
ば、 `north` の値は 0 、 `east` の値は 1 です。

enum が C ライクなら、 `as` キャスト演算子を使うことで識別子の値が得られます。

<a name="single_variant_enum"></a>

単一のヴァリアントを持つ enum の特殊なケースがあります。これは、既に存在する型
のシノニムではなく、新しく区別される型を定義するために使われます。

~~~~
enum gizmo_id = int;
~~~~

上の記述は次の省略表記です。

~~~~
enum gizmo_id { gizmo_id(int) }
~~~~

このような enum 型では、 dereference 単項演算子 `*` によって内容を取り出すこと
ができます。

~~~~
# enum gizmo_id = int;
let my_gizmo_id = gizmo_id(10);
let id_int: int = *my_gizmo_id;
~~~~

## enum のパターン

複数のヴァリアントを持つ enum 型では、 destructuring が内容を取り出す唯一の方法
です。全てのヴァリアント構築子は、次の `area` の定義のように、パターンとして使
えます。

~~~~
# type point = {x: float, y: float};
# enum shape { circle(point, float), rectangle(point, point) }
fn area(sh: shape) -> float {
    alt sh {
        circle(_, size) { float::consts::pi * size * size }
        rectangle({x, y}, {x: x2, y: y2}) { (x2 - x) * (y2 - y) }
    }
}
~~~~

次は、パラメタのない enum をマッチングする別の例です。

~~~~
# type point = {x: float, y: float};
# enum direction { north, east, south, west }
fn point_from_direction(dir: direction) -> point {
    alt dir {
        north { {x:  0f, y:  1f} }
        east  { {x:  1f, y:  0f} }
        south { {x:  0f, y: -1f} }
        west  { {x: -1f, y:  0f} }
    }
}
~~~~

## タプル

Rust のタプルはフィールドが名前を持たない (よってドット記法ではフィールドにアク
セスできません) 点を除いて、レコードと全く同じように振舞います。タプルは 0 と 1
を除く任意の数の引数を持てます (ただし、お好みで nil, `()` を空のタプルと考える
こともできます) 。

~~~~
let mytup: (int, int, float) = (10, 20, 30.0);
alt mytup {
  (a, b, c) { log(info, a + b + (c as int)); }
}
~~~~

# Rust のメモリモデル

ここで、 Rust のメモリモデルに関わる概念について説明するため、ちょっと遠回りし
ましょう。 Rust はメモリ管理に対して非常に特徴的なアプローチを採っていて、言語
の印象を形作る上で重要な役割を果たしています。 memory landscape を理解すること
は Rust 独自の特徴に出くわしたとき、その理解を容易にしてくれるでしょう。

Rust におけるメモリの見方を特徴付ける、三つの競合する目標があります。

* メモリ安全性 - Rust 言語によって管理され、アクセスできるメモリは必ず有効である
  ことが保証されます。一般的な状況下で、 Rust がセグメンテーションエラーやメモ
  リリークを引き起こすことはあり得ません。
* 性能 - 高パフォーマンスで低レベルなコードはたくさんのアロケーション戦略を採用
  する傾向にあり、低パフォーマンスで高レベルなコードには、単一の GC を基本とし
  たヒープアロケーション戦略がよく用いられます。
* 並列性 - Rust は並列に動くコードに対してもメモリ安全性を保証します。

## パフォーマンスの考慮がメモリモデルに与える影響

Rust が提供するようなメモリ安全性の保証を行う多くの言語は、単一のアロケーション
戦略を用います。つまりオブジェクトはヒープ上に存在して、必要とされている限り生
存し、定期的にガーベジコレクションされます。これは概念的にも実装も非常に素直で
す。しかし著しいコストがかかります。そのような言語はアロケーションのコストを改
善する方法を積極的に追求する傾向にあります (Java 仮想マシンを考えてみてください) 。
Rust はこの戦略を _共有ボックス (shared box)_ でサポートします。これはヒープ上
に割り当てられるメモリで、複数の変数から参照されることがあります。

対して C++ のような言語は、オブジェクトを割り当てる場所について、非常に正確な制
御が可能です。特に高価なヒープアロケーションを避けるために、オブジェクトをスタ
ック上に直接置くことがよく行われます。 Rust でも同じことが可能で、オブジェクト
が破壊された後で変数がそれを参照することのないよう、コンパイラは賢い生存期間の
解析を行います。

## 並列性の考慮がメモリモデルに与える影響

並列環境でのメモリ安全性は、同じメモリにアクセスする 2 つのスレッド間の競合条件
を回避することを意味しがちです。

高レベル言語でさえ頻繁にこの問題を解決することを避け、プログラムに競合条件のな
いことを保証するため、プログラマが正しくロックを行うことを要求します (訳注: た
ぶん unsure -> ensure) 。

Rust は単純に、メモリがタスク間で共有できないという立場からスタートします。他言
語での経験から、タスクのヒープをお互いに隔離する手法は信頼できる戦略で、プログ
ラマにとって理解しやすいと証明されています。隔離されたヒープを持つことはまた、
ガーベッジコレクションが各々のヒープごとに行われることを意味します。 Rust はガ
ーベッジコレクションのために、 'stop the world' を行うことはありません。

Rust のタスクが完全に隔離されたヒープを持つなら、タスク間で転送されるあらゆるデ
ータについて、コピーが必要となるように思えます。これはタスク間通信を実装する上
で十分に使える方法ですが、大きなデータ構造に対して非常に非効率です。

このため、 Rust はグローバルな「交換ヒープ (exchange heap) 」 を導入します。こ
こに割り当てられたオブジェクトは _ownerwhip semantics_ を持ちます。これは一つの
変数だけがそのオブジェクトを参照しているというセマンティクスです。従って、それ
らは _ユニークボックス_ として参照されます。全てのタスクはこのヒープ上にオブジ
ェクトを割り当て、高価なコピーを避けて他のタスクへ所有権を転送できます。

## 周知事項

Rust には、オブジェクトを割り当てられる 3 つの領域、スタック、ローカルヒープ、
交換ヒープ (exchange heap) があります。それぞれの領域に対応するポインタ型、借用
ポインタ (borrowed pointer, `&T`) 、共有ボックス (shared box, `@T`) 、ユニーク
ボックス (unique box, `~T`) があります。これら 3 つの sigil は言語を探検する上
でくり返し現れるでしょう。それぞれのポインタの適切な役割を学ぶことは、 Rust を
効率的に使う上での鍵となります。

# ボックスとポインタ

多くの現代的な言語とは対照的に、レコード型や enum はヒープ上に確保したメモリへ
のポインタとして表されません。それらは C や C++ のように直接に表されます。これ
は `let x = {x: 1f, y: 1f};` と記述したら、スタック上にレコードが作られることを
意味します。それをデータ構造へコピーしたら、ポインタではなくレコード全体がコピー
されます。

`point` のような小さなレコードは、通常メモリを (ヒープ上に) 確保してポインタ経
由で使うより効率的です。しかし大きなレコードや変更可能なフィールドを持つレコー
ドは、ヒープ上に単一ののコピーを持ち、ポインタを通して参照する方が有用なことが
あります。

Rust は数種のポインタ型をサポートします。安全なポインタとして、ローカルヒープ上
に割り当てられる共有ボックス `@T`, 交換ヒープ上に割り当てられるユニークボックス
`~T`, 任意のメモリを指すことが可能で、寿命がコールスタックにより管理される借用
ポインタ `&T` があります。

Rust にはまた、 `*T` と記述される安全でないポインタがあります。これは安全でない
コードでのみ用いられる、全くチェックされないポインタ型です (従って典型的な Rust
のコードでは滅多に使われません) 。

全てのポインタ型は、 `*` 単項演算子で参照する値を得られます。

## 共有ボックス

共有ボックスはヒープに割り当てられ、ガーベッジコレクションされるメモリへのポイ
ンタです。共有ボックスは式に `@` 単項演算子を適用することで作られます。式の値は
ボックス化され、その結果が返されます。代入時に起こるような共有ボックスのコピー
では、ポインタのみがコピーされボックスの中身はコピーされません。

~~~~
let x: @int = @10; // New box, refcount of 1
let y = x; // Copy the pointer, increase refcount
// When x and y go out of scope, refcount goes to 0, box is freed
~~~~

共有ボックスがタスク間を横断することは絶対にありません。

> ***注意:*** 共有ボックスは現在のところ、参照カウントと cycle collection を通
> して再利用されますが、 Tracing GC に移行する予定です。

## ユニークボックス

共有ボックスとは対照的に、ユニークボックスは単一の所有者を持ち、二つのユニーク
ボックスが同じメモリを参照することはありません。全タスクの全てのユニークボック
スは、単一の _交換ヒープ_ 上に割り当てられます。そこでは所有者がユニークである
という性質から、タスク間の受け渡しが可能です。

ユニークボックスは所有者が単一なので、コピーは新しいユニークボックスの割り当て
と、内容をコピーする操作を含みます。ユニークボックスのコピーは高価なので、暗黙
にコピー操作が入る場合コンパイルエラーになります。

~~~~
let x = ~10;
let y = x; // error: copying a non-implicitly copyable type
~~~~

本当にユニークボックスをコピーしたいときは明示的に記述する必要があります。

~~~~
let x = ~10;
let y = copy x;
~~~~

ここで 'ムーブ' (`<-`) 演算子が登場します。これは `=` に似ていますが、コピー元
を de-initialize します。それゆえユニークボックスは単一の所有者を持つという制約
条件を壊すことなく `x` から `y` へ移動できます (もしムーブ演算子の代わりに代入
演算子を使ったら、原理的にはボックスはコピーされます) 。

~~~~
let x = ~10;
let y <- x;
~~~~

> ***注意:*** このコピー vs ムーブの議論は、自動的にコピー操作をムーブに置き換
> える "last use" ルールの説明ではありません。これは継続的に変更が行われる予定
> の、発展中の領域です。

ユニークボックスは共有ボックスを含まないとき、他のタスクへ送信できます。送信す
るタスクはボックスの所有権を放棄し、以後アクセスできなくなります。受信するタス
クはボックスの唯一の所有者になります。

## 借用ポインタ

Rust の借用ポインタは汎用の参照/ポインタ型で C++ の参照型に似ていますが、有効な
メモリを指していることが保証されます。ポインタ所持者が参照先メモリの所有者とな
るユニークポインタとは対照的に、借用ポインタは絶対に所有権を持ちません。ポイン
タは任意の型から借用可能で、参照先より長生きしないことが保証されます。

~~~~
# fn work_with_foo_by_pointer(f: &~str) { }
let foo = ~"foo";
work_with_foo_by_pointer(&foo);
~~~~

次の例は借用ポインタでできないことを示しています。仮にこのような記述が可能なら、
`foo` へのポインタが `foo` 自身より長生きしてしまいます。

~~~~ {.ignore}
let foo_ptr;
{
    let foo = ~"foo";
    foo_ptr = &foo;
}
~~~~

> ***注意:*** 借用ポインタは新しく言語に追加されたものです。これはまだ広範囲に
> は使われていませんが、よくある状況下、特に引数の参照渡しのために使われるよう
> になると期待されています。 Rust の現状の引数の参照渡しの解決法は [引数渡しの
> モード](#argument-passing) を参照してください。

## Mutability

全てのポインタ型は mutable な亜種を持ち、 `@mut T` または `~mut T` のように記述
します。 dereference 演算子と変更操作を組み合わせることで、内容を書き換えること
ができます。

~~~~
fn increase_contents(pt: @mut int) {
    *pt += 1;
}
~~~~

# ベクトル

## 文字列

## ベクトルと文字列のメソッド

# クロージャ

今まで見てきたような名前付き関数は関数の外で宣言されたローカル変数を参照できま
せん。それが環境について閉じていないからです。例えば、次のようには記述できませ
ん。

~~~~ {.ignore}
let foo = 10;

fn bar() -> int {
   ret foo; // `bar` cannot refer to `foo`
}
~~~~

Rust は _クロージャ_ もサポートしています。クロージャとは、自身を囲っているスコ
ープ内の変数にアクセスできる関数です。

~~~~
# import println = io::println;
fn call_closure_with_ten(b: fn(int)) { b(10); }

let captured_var = 20;
let closure = |arg| println(#fmt("captured_var=%d, arg=%d", captured_var, arg));

call_closure_with_ten(closure);
~~~~

クロージャはバーに挟まれた引数リストで始まり、単一の式が続きます。引数の型は戻
り型と同様、一般に省略されます。コンパイラがほとんどいつも推論可能だからです。
コンパイラが補助を必要とする稀なケースでは、引数の型と戻り型の注釈が付けられま
す。

~~~~
# type mygoodness = fn(~str) -> ~str; type what_the = int;
let bloop = |well, oh: mygoodness| -> what_the { fail oh(well) };
~~~~

数種のクロージャの形式が存在し、それぞれ固有の役割があります。一番よく使われる
_スタッククロージャ_ は `fn&` 型を持ち、囲われているスコープ内の変数に直接アク
セスできます。

~~~~
let mut max = 0;
(~[1, 2, 3]).map(|x| if x > max { max = x });
~~~~

## 共有クロージャ

(訳注: 以下原文で boxed closure と書かれている部分のいくつかを共有クロージャ
(shared closure) に変更して翻訳)

データ構造にクロージャを格納する必要があるとき、スタッククロージャを格納しよう
としてもコンパイラに拒絶されます。このため、 Rust は `fn@` と記述される、任意の
寿命を持つクロージャ型 (前述の `@` ポインタに類似の共有クロージャ) を提供します。

共有クロージャは環境に直接アクセスせず、単に値 (XXX: that it closes) をプライベ
ートなデータ構造へとコピーします。これは変数への代入が不可能で、変数の更新に「
気づく」こともないことを意味します。

次のコードは、引数に与えられた文字列を追加するクロージャを生成して関数から返し、
それを呼び出します。

~~~~
use std;

fn mk_appender(suffix: ~str) -> fn@(~str) -> ~str {
    ret fn@(s: ~str) -> ~str { s + suffix };
}

fn main() {
    let shout = mk_appender(~"!");
    io::println(shout(~"hey ho, let's go"));
}
~~~~

この例は長いクロージャ構文 `fn@(s: ~str) ...` を使用し、共有クロージャを宣言し
ていることを明示しています。実際には通常、共有クロージャは以前紹介した短いクロ
ージャ構文を用いて定義されます。この場合、コンパイラがクロージャの型を推論しま
す。よって、上述の例は次のようにも記述できます。

~~~~
fn mk_appender(suffix: ~str) -> fn@(~str) -> ~str {
    ret |s| s + suffix;
}
~~~~

## ユニーククロージャ

`fn~` と記述され `~` ポインタ型に類似するユニーククロージャは、プロセス間で安全
に送信できるものを所有します。共有クロージャと同じように値 (XXX: that it close
over) をコピーしますが、さらにそれを「所有」します。つまり、他のコードはそれに
アクセスできません。ユニーククロージャは並列コード内で、特に[タスク ][#tasks]
を生成するために使われます。

## クロージャの互換性

Rust のクロージャには、 `fn()` を期待する関数に (引数と返り値の型が合う限り) 任
意の種類のクロージャを渡せるという、素敵な性質があります。よって、引数で渡され
る関数について、単なる呼び出し以上のことをしない高階関数を書く場合は、ほぼ常に
引数の型を `fn()` と指定すべきです。そうすれば、呼び出し側が好きなものを何でも
渡せる柔軟性を持ちます。


~~~~
fn call_twice(f: fn()) { f(); f(); }
call_twice(|| { ~"I am an inferred stack closure"; } );
call_twice(fn&() { ~"I am also a stack closure"; } );
call_twice(fn@() { ~"I am a boxed closure"; });
call_twice(fn~() { ~"I am a unique closure"; });
fn bare_function() { ~"I am a plain function"; }
call_twice(bare_function);
~~~~

## do 構文

## for ループ

# クラス

# 引数渡し

## Safe reference

## safe references の他の利用

## 引数渡しのスタイル

# Generics

## 総称関数

## 総称データ型

## 型推論と総称性

## 多相的なビルトイン

## kind

## 総称関数と引数渡し

## モジュールと crate

## ローカルモジュール

## crate

## Using other crates

## コアライブラリ

## ミニマルな例

## インポート

## エクスポート

## ネームスペース

## (名前) 解決

# インターフェイス

インターフェイスは、オブジェクト指向言語がメソッドと継承を用いて解決する、値多
相 (value polymorphism) に対する Rust の答えです。例えば、複数のコレクション型
に作用する関数を書くのに用います。

> ***注意:*** この機能はとても新しく、より進んだ使い方に適用するには少し拡張が
> 必要でしょう。

## 宣言

インターフェイスはメソッドの集合で構成されます。メソッドはドット記法
`self.foo(arg1, arg2)` を使って、値 `self` と複数の引数に対して適用できます。

例えば文字列に変換できるオブジェクトのために、一つの (インターフェイス名と同名
の) メソッド `to_str` を持つインターフェイス `to_str` を宣言できます。

~~~~
iface to_str {
    fn to_str() -> ~str;
}
~~~~

## 実装

実際に型にインターフェイスを実装するためには、 `impl` 形式を使います。次の例は
`int` と `~str` 型に `to_str` の実装を定義します。

~~~~
# iface to_str { fn to_str() -> ~str; }
impl of to_str for int {
    fn to_str() -> ~str { int::to_str(self, 10u) }
}
impl of to_str for ~str {
    fn to_str() -> ~str { self }
}
~~~~

これらが与えられるとき、、 `1.to_str()` を呼び出すと `~"1"` 、また
`(~"foo").to_str()` を呼び出すと `~"foo"` が得られます。これは基本的に静的な多
重定義の一種です。 Rust は `to_str` メソッドの呼び出しを見つけると、名前の一致
するメソッドを持ち、型の一致する実装を探し出して、単純にそれを呼び出します。

## スコープ

実装はグローバルには可視になりません。メソッドが実装へと解決されるには、実装が
スコープ内に存在する必要があります。実装したインターフェイスの名前を使うことで、
実装をインポートおよびエクスポートできます (同じ名前を持つ複数の実装は、問題な
く同スコープ内に存在できます) 。もしくは、実装に明示的に名前を与えることもでき
ます。

~~~~
# iface to_str { fn to_str() -> ~str; }
impl nil_to_str of to_str for () {
    fn to_str() -> ~str { ~"()" }
}
~~~~

## 制約付き型パラメタ

値多相の有用なところは、静的である必要がないことです。仮にオブジェクト指向言語
で、オブジェクトの sub-type が正確に判明していないとメソッドを呼び出せないとし
たら、たいしたことはできない (that would not get you very far) でしょう。
コンパイル時に型の分からないメソッドを呼びだすために、型パラメタに「制約
(bound) 」を明示できます。

~~~~
# iface to_str { fn to_str() -> ~str; }
fn comma_sep<T: to_str>(elts: ~[T]) -> ~str {
    let mut result = ~"", first = true;
    for elts.each |elt| {
        if first { first = false; }
        else { result += ~", "; }
        result += elt.to_str();
    }
    ret result;
}
~~~~

この構文は型パラメタがコピー可能 (原理上は別の種類の制約) である明示する構文と
似ています。 `T` がインターフェイス `to_str` に適合すると宣言することで、関数内
でその型の値に対してインターフェイスからメソッドを呼び出すことが可能になります。
また、要素の型がスコープ内で `to_str` の実装を持たない配列に対して `comma_sep`
を呼び出そうとすると、コンパイルエラーを引き起こします。

## 多相インターフェイス

インターフェイスは型パラメタを含むことができます。次の例は一般化されたシーケン
ス型のインターフェイスを定義します。

~~~~
iface seq<T> {
    fn len() -> uint;
    fn iter(fn(T));
}
impl <T> of seq<T> for ~[T] {
    fn len() -> uint { vec::len(self) }
    fn iter(b: fn(T)) {
        for self.each |elt| { b(elt); }
    }
}
~~~~

実装では、インターフェイス型を指定するためにパラメタ `T` を使う前に、 `T` を明
示的に宣言する必要があることに注意してください。これは例えば、 `of` 節が型を指
定するのではなく参照する `seq<int>` の実装を指定することも可能なため、必要とな
ります。

## インターフェイス型へのキャスト

上述の方法で、与えられたインターフェイスに適合する*単一の*不明な型を持つ値に対
して、多相的に振る舞う関数を定義できます。しかし、次の関数について考えてくださ
い。

~~~~
# type circle = int; type rectangle = int;
# iface drawable { fn draw(); }
# impl of drawable for int { fn draw() {} }
# fn new_circle() -> int { 1 }
fn draw_all<T: drawable>(shapes: ~[T]) {
    for shapes.each |shape| { shape.draw(); }
}
# let c: circle = new_circle();
# draw_all(~[c]);
~~~~

この関数は circle の配列や square の配列 (適切な `drawable` インターフェイスが
定義されていると仮定します) に対して呼び出せます。しかし circle と square 両方
を含む配列に対しては呼び出せません。

これが必要な場合、インターフェイスの名前を型として使うことが可能で、関数は単純
に、次のように記述することになります。

~~~~
# iface drawable { fn draw(); }
fn draw_all(shapes: ~[drawable]) {
    for shapes.each |shape| { shape.draw(); }
}
~~~~

もはや型パラメタはありません (関数を適用する単一の型がないため) 。代わりに
`drawable` が、 `drawable` の実装が存在する値と、その実装に対応するメソッドを探
索する場所の情報を含む、参照カウントされるボックスを参照する型として使われます
(XXX: 訳悪) 。これは多くのオブジェクト指向言語での 'vtable' (仮想関数テーブル)
に、非常によく似ています。

(訳注: メモリレイアウトは `@(\*vtable, value)` みたいな感じだと思われる。要確認)

このような値を構築するためには、値をインターフェイス型にキャストする `as` 演算
子を使います。

~~~~
# type circle = int; type rectangle = int;
# iface drawable { fn draw(); }
# impl of drawable for int { fn draw() {} }
# fn new_circle() -> int { 1 }
# fn new_rectangle() -> int { 2 }
# fn draw_all(shapes: ~[drawable]) {}
let c: circle = new_circle();
let r: rectangle = new_rectangle();
draw_all(~[c as drawable, r as drawable]);
~~~~

これは実装についての情報と一緒に、値をボックスに格納します (実装はキャストのス
コープ内で探索されます) 。 `drawable` 型は単純にそのようなボックスを参照し、た
とえスコープ上にどんな実装があっても、ボックスに対するメソッドの呼び出しは常に
機能します。

ボックスの割り当ては、単純に型パラメタを使って値をそのまま渡すより少し高価で、
静的に解決されるメソッド呼び出しよりずっと高価です。

## インターフェイスなしの実装
